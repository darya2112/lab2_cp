data                   /* блок программы с данными */


mass:                   /*Инициализация массива. метка (адрес) начала массива */
        .byte 9, 123, 95, 22, 91, 52, 251, 1, 30, 76
mass_end:               /* метка (адрес) конца массива.Ссылается на следующую ячейку в памяти */

print_format:           /* формат вывода для printf */
    .string "Sum of all array elements: %d\n"

.text                   /* блок программы с командами (основная часть программы) */

.global main            /* говорим, чтобы при запуске программы он начинал с main */
.type main, @function   /* указываем, что main - функция */

/*РЕГИСТРЫ:
eax - адрес текущего элемента массива(где МЫ находимся)
ebx - значение текущего элемента массива
ecx - номер текущего элемента массива (с 0 по 9, так как всего 10 элементов.То есть индекс массива)
edx - промежуточное значение используем для проверки на четность/нечетность
esi - счет суммы  элементов полученного массива
*/

main:                       /* ИНИЦИАЛИЗАЦИЯ ДАННЫХ */
    movl $mass, %eax        /*Перемещаем  адрес текущего элемента массива в eax */
    xorl %ecx, %ecx         /*Исключающие ИЛИ.Если значения в регистрах совпадают,то 0,иначе 1.В некой степени обнуляем счетчик элементов массива(индексов) */
    xorl %esi, %esi         /* Искл ИЛИ.обнуляем сумму элементов полученного массива */
    xorl %ebx, %ebx          /*Исключающее ИЛИ. Обнули значение текущкго элемента массива*/

start:                      /* ЦИКЛ СОГЛАСНО 12 ВАРИНТУ */
    movb (%eax), %bl         /* ОБращаемся к памяти ячейки текущего элемента массива ( aex) и перемещаем его в регистр ebx */

    movl %ecx, %edx         /* Перемещаем в edx индекс текущего элемента */
    and $1, %edx            /* Логическое И.Проверяем последний бит (если стоит в 1, то значение нечет) 1 and 5=001 and 101=001 =1 (в десят с.с)*/
    cmpl $1, %edx           /* Сравниваем  1 c полученным результатом после выполнения логического и*/
    jne chet                /* Если значения  не совпадает, то прыгаем на  метку chet (четное) иначе переходим на метку нечетное */

nechet:                     /* РАБОТА С НЕЧЕТ ЧИСЛАМИ */
    or $0x10, %bl           /* Логическое или.Установка 1 В четвертоМ бите (0x10 = 0001 0000) */
    jmp check_end_mass      /* Переходим на метку check_end_mass */

chet:                       /* РАБОТА С ЧЕТНЫМИ ЧИСЛАМИ */
    and $0xDF, %bl          /* Логическое И. 0xDF- 16 С.Ч, установка 0 в пятом бите (0xDF = 1101 1111).bl-8 бит регистра ebx */
    heck_end_mass:             /* ПРОВЕРКА НА КОНЕЦ МАССИВА */
    movb %bl, (%eax)        /* перезаписываем старое значение текущего элемента массива в адрес ячйки памяти текущего элемента(aex)  */
    addl %ebx, %esi         /* Суммма элементов полученного массива */
    inc %eax                /* Инкремент,увеличиваем адре текущего элемента  массива на 1 (числа в массиве = 1 байту=8 бит) */
    inc %ecx                /* Инкремент, увеличиваем значение номера текущего элемента */

    cmpl $mass_end, %eax    /* Сравнение:если адрес текущего элемента массива (eax)
                               не совпадает с концом массива (mass_end) */
    jne start               /* То повторяем действия заново -переходим на метку start */


                            /* ВЫВОД МАССИВА НА ЭКРАН */
    pushl %esi              /* помещаем в стэк текущее значение cуммы  элементов массива */
    pushl $print_format     /* помещаем в стэк формат вывода (строку вывода) */
    call printf             /* вызов функцию printf из библиотеки С */
    addl $8, %esp           /*Обнуляем последние 2 заполненные значения стека.Используем суммирование: каждый адрес занимает 4 байт,поэтому суммируем 8 и esр(указателm  где находится стек(адреса куда бу>
    movl $1, %eax           /* 1 - код, означающая ВОЗВРАТ ЗНАЧЕНИЯ  */
    movl $0, %ebx           /* 0 -код оштбки- возвращаемое значение */
    int $0x80               /* вызвать возврат значения */

